#!/usr/bin/env node
const fs = require('fs')
const { resolve } = require('path')
const path = require('path')
const cwd = process.cwd()
const rl = require('readline').createInterface({
  input: process.stdin,
  output: process.stdout
})

const samplePath = path.resolve(__dirname, '../sample')
const dist = path.resolve(cwd, 'dist')
if (fs.existsSync(dist)) {
  fs.rmdirSync(dist, {
    recursive: true
  })
}
fs.mkdirSync(dist)

function inputTitle () {
  return new Promise((resolve, reject) => {
    rl.question('请输入你的网站标题：', title => {
      resolve(title)
    })
  })
}

function  createHtml (title) {
  return new Promise((resolve, reject) => {
    var file = filePath = samplePath + '/index.html'
    fs.readFile(file, 'utf8', (err, data) => {
      if (err) return fatal(err)
      fs.open(dist + '/index.html', 'w', (err, fd) => {
        if (err) return fatal(err)
        fs.write(fd, data.replace(/\{\{title\}\}/g, title), (err) => {
          if (err) return fatal(err)
          fs.close(fd, err => {
            if (err) return fatal(err)
            resolve(true)
          })        
        })
      })
    })
  })
}

function copySrc () {
  return new Promise ((resolve, reject) => {
    const src = path.resolve(samplePath, 'src')
    const distSrc = path.resolve(dist, 'src')
    fs.mkdirSync(distSrc)
    copyDir(src, distSrc)
    resolve()
  })
}

function copyDir (src, dist) {
  var files = fs.readdirSync(src)
  files.forEach(file => {
    let srcFile = path.resolve(src, file)
    let distFile = path.resolve(dist, file)
    let stats = fs.statSync(srcFile)
    if (stats.isFile()) {
      fs.createReadStream(srcFile).pipe(fs.createWriteStream(distFile))
      // const readStream = fs.createReadStream(srcFile)
      // const writeStream = fs.createWriteStream(distFile)
      // readStream.pipe(writeStream);
      // readStream.on('readable', () => {
      //   console.log(srcFile, ' :read stream readable')
      // })
      // readStream.on('data', chunk => {
      //   console.log(srcFile, ' :read stream data:', chunk)
      // })
      // readStream.on('end', () => {
      //   console.log(srcFile, ' :read stream end')
      // })

      // writeStream.on('finish', () => {
      //   console.log('writeStream finish')
      // })

      // writeStream.on('close', () => {
      //   console.log('writeStream close')
      // })

      // writeStream.on('pipe', () => {
      //   console.log('writeStream pipe')
      // })
    }
    if (stats.isDirectory()) {
      fs.mkdirSync(distFile)
      copyDir(srcFile, distFile)
    }
  })
}

function createConfigs(title) {
  return new Promise((resolve, reject) => {
    let now = Date.now()
    fs.open(dist + '/configs.js', 'w', (err, fd) => {
      if (err) return reject(err)
      fs.write(fd, 
`export default {
  title: "${title}",
  name: "test",
  level: 7,
  time: ${now}
}
`, (err) => {
        if (err) return fatal(err)
        fs.close(fd, err => {
          if (err) return fatal(err)
          resolve(true)
        })
      })
    })
  })
}

async function run () {
  // let title = await inputTitle().catch(err => {
  //   console.log('input title:', err)
  //   process.exit()
  // })
  // console.log('title:', title)
  // if (!title) return
  let title = 'webgen test'
  Promise.all([
    createHtml(title),
    createConfigs(title),
    copySrc()
  ]).then(() => {
    process.exit()
  })
}

function fatal (err) {
  console.error(err)
  process.exit()
}

run()
